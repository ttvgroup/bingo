const Bet = require('../models/Bet');
const User = require('../models/User');
const Result = require('../models/Result');
const telegramService = require('./telegramService');
const redisClient = require('../config/redis');
const ApiError = require('../utils/error');
const config = require('../config');
const logger = require('../utils/logger');

/**
 * Ki·ªÉm tra k·∫øt qu·∫£ v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i c√°c c∆∞·ª£c
 * @param {string} resultId - ID c·ªßa k·∫øt qu·∫£
 */
exports.checkResults = async (resultId) => {
  const result = await Result.findById(resultId);
  if (!result) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£');
  }

  const bets = await Bet.find({ status: 'pending' }).populate('userId');
  const winners = [];
  const redisPipeline = redisClient.multi();

  // S·ª≠ d·ª•ng session ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh to√†n v·∫πn
  const session = await User.startSession();
  session.startTransaction();

  try {
    // L·∫•y t·∫•t c·∫£ c√°c s·ªë t·ª´ k·∫øt qu·∫£
    const resultNumbers = extractResultNumbers(result);

    for (const bet of bets) {
      let isWinner = false;
      let winAmount = 0;
      
      // Ki·ªÉm tra k·∫øt qu·∫£ d·ª±a v√†o lo·∫°i c∆∞·ª£c
      switch (bet.betType) {
        case '2D':
          isWinner = check2D(bet.numbers, resultNumbers.twoDigits);
          if (isWinner) {
            winAmount = bet.amount * config.payoutRatios['2D'];
          }
          break;
        case '3D':
          isWinner = check3D(bet.numbers, resultNumbers.threeDigits);
          if (isWinner) {
            winAmount = bet.amount * config.payoutRatios['3D'];
          }
          break;
        case '4D':
          isWinner = check4D(bet.numbers, resultNumbers.fourDigits);
          if (isWinner) {
            winAmount = bet.amount * config.payoutRatios['4D'];
          }
          break;
        case 'Bao l√¥ 2D':
          isWinner = checkBaoLo2D(bet.numbers, resultNumbers, bet.provinceCode);
          if (isWinner) {
            // Chia cho s·ªë l√¥ v√¨ c∆∞·ª£c bao l√¥ l√† ƒë·∫∑t c∆∞·ª£c cho t·∫•t c·∫£ c√°c l√¥
            const lotsPerProvince = config.baoLoQuantity['Bao l√¥ 2D'];
            winAmount = (bet.amount / lotsPerProvince) * config.payoutRatios['Bao l√¥ 2D'];
          }
          break;
        case 'Bao l√¥ 3D':
          isWinner = checkBaoLo3D(bet.numbers, resultNumbers, bet.provinceCode);
          if (isWinner) {
            const lotsPerProvince = config.baoLoQuantity['Bao l√¥ 3D'];
            winAmount = (bet.amount / lotsPerProvince) * config.payoutRatios['Bao l√¥ 3D'];
          }
          break;
        case 'Bao l√¥ 4D':
          isWinner = checkBaoLo4D(bet.numbers, resultNumbers, bet.provinceCode);
          if (isWinner) {
            const lotsPerProvince = config.baoLoQuantity['Bao l√¥ 4D'];
            winAmount = (bet.amount / lotsPerProvince) * config.payoutRatios['Bao l√¥ 4D'];
          }
          break;
      }
      
      if (isWinner) {
        bet.status = 'won';
        bet.winAmount = winAmount;
        const user = bet.userId;
        user.balance += winAmount;
        await user.save({ session });
        redisPipeline.setEx(`user:${user.telegramId}`, config.cacheExpiry, JSON.stringify(user));
        winners.push({ userId: user, amount: winAmount, betType: bet.betType });
      } else {
        bet.status = 'lost';
      }
      
      bet.resultId = resultId;
      await bet.save({ session });

      // Th√¥ng b√°o cho ng∆∞·ªùi d√πng
      if (bet.status === 'won') {
        const message = `üéâ *CH√öC M·ª™NG!* üéâ\n\nB·∫°n ƒë√£ tr√∫ng th∆∞·ªüng!\n\nüéÆ Lo·∫°i c∆∞·ª£c: ${bet.betType}\nüî¢ S·ªë ƒë√£ ƒë·∫∑t: ${bet.numbers}\nüí∞ S·ªë ti·ªÅn c∆∞·ª£c: ${bet.amount}\nüíµ Ti·ªÅn th·∫Øng: ${winAmount}\n\nS·ªë d∆∞ hi·ªán t·∫°i: ${bet.userId.balance}`;
        await telegramService.sendMessage(bet.userId.telegramId, message);
      } else {
        const message = `R·∫•t ti·∫øc! B·∫°n ƒë√£ kh√¥ng tr√∫ng.\nS·ªë c∆∞·ª£c: ${bet.numbers} (${bet.betType})\nS·ªë d∆∞: ${bet.userId.balance}`;
        await telegramService.sendMessage(bet.userId.telegramId, message);
      }
    }

    // Commit transaction
    await session.commitTransaction();

    // Th·ª±c hi·ªán Redis pipeline
    try {
      await redisPipeline.exec();
    } catch (redisErr) {
      logger.error('Redis pipeline error:', redisErr);
    }

    if (winners.length > 0) {
      await telegramService.notifyWinners(winners, result);
    }
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error processing bets results:', error);
    throw error;
  } finally {
    session.endSession();
  }
};

/**
 * Tr√≠ch xu·∫•t t·∫•t c·∫£ c√°c s·ªë t·ª´ k·∫øt qu·∫£
 * @param {Object} result - K·∫øt qu·∫£ x·ªï s·ªë
 * @returns {Object} C√°c s·ªë ƒë√£ tr√≠ch xu·∫•t
 */
function extractResultNumbers(result) {
  const twoDigits = [];
  const threeDigits = [];
  const fourDigits = [];
  const provinceResults = {};
  
  for (const province of result.provinces) {
    const provinceCode = province.code;
    provinceResults[provinceCode] = {
      twoDigits: [],
      threeDigits: [],
      fourDigits: []
    };
    
    // 2D: Gi·∫£i 8 v√† 2 s·ªë cu·ªëi c·ªßa t·∫•t c·∫£ c√°c gi·∫£i
    provinceResults[provinceCode].twoDigits.push(province.results.eighth);
    provinceResults[provinceCode].twoDigits.push(province.results.special.slice(-2));
    provinceResults[provinceCode].twoDigits.push(province.results.first.slice(-2));
    provinceResults[provinceCode].twoDigits.push(province.results.second.slice(-2));
    
    for (const num of province.results.third) {
      provinceResults[provinceCode].twoDigits.push(num.slice(-2));
    }
    
    for (const num of province.results.fourth) {
      provinceResults[provinceCode].twoDigits.push(num.slice(-2));
    }
    
    provinceResults[provinceCode].twoDigits.push(province.results.fifth.slice(-2));
    
    for (const num of province.results.sixth) {
      provinceResults[provinceCode].twoDigits.push(num.slice(-2));
    }
    
    provinceResults[provinceCode].twoDigits.push(province.results.seventh.slice(-2));
    
    // 3D: Gi·∫£i 7 v√† 3 s·ªë cu·ªëi c·ªßa gi·∫£i ƒë·∫∑c bi·ªát
    provinceResults[provinceCode].threeDigits.push(province.results.seventh);
    provinceResults[provinceCode].threeDigits.push(province.results.special.slice(-3));
    provinceResults[provinceCode].threeDigits.push(province.results.first.slice(-3));
    provinceResults[provinceCode].threeDigits.push(province.results.second.slice(-3));
    
    for (const num of province.results.third) {
      provinceResults[provinceCode].threeDigits.push(num.slice(-3));
    }
    
    for (const num of province.results.fourth) {
      provinceResults[provinceCode].threeDigits.push(num.slice(-3));
    }
    
    provinceResults[provinceCode].threeDigits.push(province.results.fifth.slice(-3));
    
    for (const num of province.results.sixth) {
      provinceResults[provinceCode].threeDigits.push(num.slice(-3));
    }
    
    // 4D: T·∫•t c·∫£ c√°c s·ªë 4 ch·ªØ s·ªë t·ª´ c√°c gi·∫£i
    for (const num of province.results.sixth) {
      provinceResults[provinceCode].fourDigits.push(num);
    }
    
    provinceResults[provinceCode].fourDigits.push(province.results.fifth);
    
    // Th√™m v√†o danh s√°ch t·ªïng h·ª£p
    twoDigits.push(...provinceResults[provinceCode].twoDigits);
    threeDigits.push(...provinceResults[provinceCode].threeDigits);
    fourDigits.push(...provinceResults[provinceCode].fourDigits);
  }
  
  return {
    twoDigits,
    threeDigits,
    fourDigits,
    provinceResults
  };
}

/**
 * Ki·ªÉm tra c∆∞·ª£c 2D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Array} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function check2D(betNumber, resultNumbers) {
  return resultNumbers.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c 3D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Array} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function check3D(betNumber, resultNumbers) {
  return resultNumbers.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c 4D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Array} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function check4D(betNumber, resultNumbers) {
  return resultNumbers.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c Bao l√¥ 2D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Object} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @param {string} provinceCode - M√£ t·ªânh
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function checkBaoLo2D(betNumber, resultNumbers, provinceCode) {
  // N·∫øu kh√¥ng c√≥ m√£ t·ªânh, ki·ªÉm tra t·∫•t c·∫£ c√°c t·ªânh
  if (!provinceCode) {
    return resultNumbers.twoDigits.includes(betNumber);
  }
  
  // N·∫øu c√≥ m√£ t·ªânh, ch·ªâ ki·ªÉm tra t·ªânh ƒë√≥
  if (!resultNumbers.provinceResults[provinceCode]) {
    return false;
  }
  
  return resultNumbers.provinceResults[provinceCode].twoDigits.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c Bao l√¥ 3D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Object} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @param {string} provinceCode - M√£ t·ªânh
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function checkBaoLo3D(betNumber, resultNumbers, provinceCode) {
  // N·∫øu kh√¥ng c√≥ m√£ t·ªânh, ki·ªÉm tra t·∫•t c·∫£ c√°c t·ªânh
  if (!provinceCode) {
    return resultNumbers.threeDigits.includes(betNumber);
  }
  
  // N·∫øu c√≥ m√£ t·ªânh, ch·ªâ ki·ªÉm tra t·ªânh ƒë√≥
  if (!resultNumbers.provinceResults[provinceCode]) {
    return false;
  }
  
  return resultNumbers.provinceResults[provinceCode].threeDigits.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c Bao l√¥ 4D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Object} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @param {string} provinceCode - M√£ t·ªânh
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function checkBaoLo4D(betNumber, resultNumbers, provinceCode) {
  // N·∫øu kh√¥ng c√≥ m√£ t·ªânh, ki·ªÉm tra t·∫•t c·∫£ c√°c t·ªânh
  if (!provinceCode) {
    return resultNumbers.fourDigits.includes(betNumber);
  }
  
  // N·∫øu c√≥ m√£ t·ªânh, ch·ªâ ki·ªÉm tra t·ªânh ƒë√≥
  if (!resultNumbers.provinceResults[provinceCode]) {
    return false;
  }
  
  return resultNumbers.provinceResults[provinceCode].fourDigits.includes(betNumber);
}

/**
 * Th√¥ng b√°o k·∫øt qu·∫£ m·ªõi
 * @param {Object} result - K·∫øt qu·∫£ x·ªï s·ªë
 */
exports.notifyResult = async (result) => {
  const channelId = config.telegramChannelId;
  if (!channelId) {
    logger.error('TELEGRAM_CHANNEL_ID not configured');
    return;
  }
  
  try {
    // Format ng√†y
    const formattedDate = new Date(result.date).toLocaleDateString('vi-VN');
    
    let message = `üé≤ *K·∫æT QU·∫¢ X·ªî S·ªê ${result.region.toUpperCase()} - ${formattedDate} (${result.weekday})*\n\n`;
    
    // Th√¥ng tin t·ª´ng t·ªânh
    for (const province of result.provinces) {
      message += `üèÜ *${province.name.toUpperCase()} (${province.code})*\n`;
      message += `‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n`;
      message += `üî∏ Gi·∫£i 8: ${province.results.eighth}\n`;
      message += `üî∏ Gi·∫£i 7: ${province.results.seventh}\n`;
      message += `üî∏ Gi·∫£i 6: ${province.results.sixth.join(', ')}\n`;
      message += `üî∏ Gi·∫£i 5: ${province.results.fifth}\n`;
      message += `üî∏ Gi·∫£i 4: ${province.results.fourth.join(', ')}\n`;
      message += `üî∏ Gi·∫£i 3: ${province.results.third.join(', ')}\n`;
      message += `üî∏ Gi·∫£i 2: ${province.results.second}\n`;
      message += `üî∏ Gi·∫£i 1: ${province.results.first}\n`;
      message += `üî∏ Gi·∫£i ƒê·∫∑c Bi·ªát: ${province.results.special}\n\n`;
    }
    
    // Th√™m th√¥ng tin ph·ª•
    message += `üì± Ki·ªÉm tra v√© s·ªë c·ªßa b·∫°n ngay b√¢y gi·ªù!`;
    
    await telegramService.sendMessage(channelId, message, { parse_mode: 'Markdown' });
  } catch (error) {
    logger.error('Failed to notify result:', error);
  }
};