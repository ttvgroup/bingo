const Bet = require('../models/Bet');
const User = require('../models/User');
const Result = require('../models/Result');
const telegramService = require('./telegramService');
const redisClient = require('../config/redis');
const ApiError = require('../utils/error');
const config = require('../config');
const logger = require('../utils/logger');
const helper = require('../utils/helper');
const mongoose = require('mongoose');

/**
 * Ki·ªÉm tra k·∫øt qu·∫£ v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i c√°c c∆∞·ª£c
 * @param {string} resultId - ID c·ªßa k·∫øt qu·∫£
 * @returns {Object} Th·ªëng k√™ k·∫øt qu·∫£ ki·ªÉm tra
 */
exports.checkResults = async (resultId) => {
  const result = await Result.findById(resultId);
  if (!result) {
    throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£');
  }

  // L·∫•y t·∫•t c·∫£ c√°c c∆∞·ª£c ch∆∞a c√≥ k·∫øt qu·∫£
  const bets = await Bet.find({ 
    status: 'pending',
    provinceCode: { $in: result.provinces.map(p => p.code) }
  }).populate('userId');
  
  if (bets.length === 0) {
    return { message: 'Kh√¥ng c√≥ c∆∞·ª£c n√†o c·∫ßn ki·ªÉm tra' };
  }

  // Th·ªëng k√™
  const summary = {
    totalBets: bets.length,
    winners: 0,
    losers: 0,
    totalWinAmount: 0,
    winnersByType: {},
    winnersList: []
  };

  // S·ª≠ d·ª•ng session ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh to√†n v·∫πn
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    // L·∫•y t·∫•t c·∫£ c√°c s·ªë t·ª´ k·∫øt qu·∫£
    const resultNumbers = extractResultNumbers(result);

    for (const bet of bets) {
      let isWinner = false;
      let winAmount = 0;
      
      // Ki·ªÉm tra k·∫øt qu·∫£ d·ª±a v√†o lo·∫°i c∆∞·ª£c
      switch (bet.betType) {
        case '2D':
          isWinner = check2D(bet.numbers, resultNumbers.twoDigits);
          if (isWinner) {
            winAmount = bet.amount * config.payoutRatios['2D'];
          }
          break;
        case '3D':
          isWinner = check3D(bet.numbers, resultNumbers.threeDigits);
          if (isWinner) {
            winAmount = bet.amount * config.payoutRatios['3D'];
          }
          break;
        case '4D':
          isWinner = check4D(bet.numbers, resultNumbers.fourDigits);
          if (isWinner) {
            winAmount = bet.amount * config.payoutRatios['4D'];
          }
          break;
        case 'Bao l√¥ 2D':
          isWinner = checkBaoLo2D(bet.numbers, resultNumbers, bet.provinceCode);
          if (isWinner) {
            // Chia cho s·ªë l√¥ v√¨ c∆∞·ª£c bao l√¥ l√† ƒë·∫∑t c∆∞·ª£c cho t·∫•t c·∫£ c√°c l√¥
            const lotsPerProvince = config.baoLoQuantity['Bao l√¥ 2D'];
            winAmount = (bet.amount / lotsPerProvince) * config.payoutRatios['Bao l√¥ 2D'];
          }
          break;
        case 'Bao l√¥ 3D':
          isWinner = checkBaoLo3D(bet.numbers, resultNumbers, bet.provinceCode);
          if (isWinner) {
            const lotsPerProvince = config.baoLoQuantity['Bao l√¥ 3D'];
            winAmount = (bet.amount / lotsPerProvince) * config.payoutRatios['Bao l√¥ 3D'];
          }
          break;
        case 'Bao l√¥ 4D':
          isWinner = checkBaoLo4D(bet.numbers, resultNumbers, bet.provinceCode);
          if (isWinner) {
            const lotsPerProvince = config.baoLoQuantity['Bao l√¥ 4D'];
            winAmount = (bet.amount / lotsPerProvince) * config.payoutRatios['Bao l√¥ 4D'];
          }
          break;
      }
      
      // C·∫≠p nh·∫≠t th√¥ng tin c∆∞·ª£c
      if (isWinner) {
        bet.status = 'won';
        bet.winAmount = Math.floor(winAmount); // L√†m tr√≤n xu·ªëng
        
        // C·∫≠p nh·∫≠t th·ªëng k√™
        summary.winners++;
        summary.totalWinAmount += bet.winAmount;
        
        // Th√™m v√†o danh s√°ch ng∆∞·ªùi th·∫Øng
        summary.winnersList.push({
          betId: bet._id,
          userId: bet.userId._id,
          telegramId: bet.userId.telegramId,
          username: bet.userId.username,
          numbers: bet.numbers,
          betType: bet.betType,
          amount: bet.amount,
          winAmount: bet.winAmount
        });
        
        // Th·ªëng k√™ theo lo·∫°i c∆∞·ª£c
        if (!summary.winnersByType[bet.betType]) {
          summary.winnersByType[bet.betType] = {
            count: 0,
            totalWin: 0
          };
        }
        summary.winnersByType[bet.betType].count++;
        summary.winnersByType[bet.betType].totalWin += bet.winAmount;
        
        // KH√îNG c·∫≠p nh·∫≠t s·ªë d∆∞ ng∆∞·ªùi d√πng ·ªü ƒë√¢y - s·∫Ω c·∫≠p nh·∫≠t sau khi admin x√°c nh·∫≠n
      } else {
        bet.status = 'lost';
        summary.losers++;
      }
      
      // Li√™n k·∫øt v·ªõi k·∫øt qu·∫£
      bet.resultId = resultId;
      await bet.save({ session });

      // Th√¥ng b√°o cho ng∆∞·ªùi d√πng
      if (bet.status === 'won') {
        const message = `üéâ *TH√îNG B√ÅO TR√öNG TH∆Ø·ªûNG* üéâ\n\n` + 
          `B·∫°n ƒë√£ tr√∫ng th∆∞·ªüng!\n\n` + 
          `üéÆ Lo·∫°i c∆∞·ª£c: ${bet.betType}\n` + 
          `üî¢ S·ªë ƒë√£ ƒë·∫∑t: ${bet.numbers}\n` + 
          `üí∞ S·ªë ti·ªÅn c∆∞·ª£c: ${helper.formatCurrency(bet.amount)}\n` + 
          `üíµ Ti·ªÅn th·∫Øng: ${helper.formatCurrency(bet.winAmount)}\n\n` +
          `*Ti·ªÅn th∆∞·ªüng s·∫Ω ƒë∆∞·ª£c chuy·ªÉn v√†o t√†i kho·∫£n sau khi ƒë∆∞·ª£c x√°c nh·∫≠n.*`;
          
        await telegramService.sendMessage(bet.userId.telegramId, message);
      } else {
        const message = `R·∫•t ti·∫øc! B·∫°n ƒë√£ kh√¥ng tr√∫ng.\n` + 
          `S·ªë c∆∞·ª£c: ${bet.numbers} (${bet.betType})\n` + 
          `S·ªë d∆∞ hi·ªán t·∫°i: ${helper.formatCurrency(bet.userId.balance)}`;
          
        await telegramService.sendMessage(bet.userId.telegramId, message);
      }
    }

    // Commit transaction
    await session.commitTransaction();
    
    // Th√¥ng b√°o tr√™n k√™nh chung
    if (summary.winners > 0) {
      let channelMsg = `üèÜ *K·∫æT QU·∫¢ X·ªî S·ªê NG√ÄY ${helper.formatDate(result.date)}* üèÜ\n\n`;
      channelMsg += `C√≥ ${summary.winners} ng∆∞·ªùi tr√∫ng gi·∫£i v·ªõi t·ªïng gi√° tr·ªã ${helper.formatCurrency(summary.totalWinAmount)}!\n\n`;
      
      for (const [type, stats] of Object.entries(summary.winnersByType)) {
        channelMsg += `${type}: ${stats.count} ng∆∞·ªùi tr√∫ng, ${helper.formatCurrency(stats.totalWin)}\n`;
      }
      
      await telegramService.sendChannelMessage(channelMsg);
    }

    return summary;
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error processing bets results:', error);
    throw error;
  } finally {
    session.endSession();
  }
};

/**
 * X√°c nh·∫≠n thanh to√°n cho nh·ªØng ng∆∞·ªùi tr√∫ng
 * @param {Array} betIds - Danh s√°ch ID c∆∞·ª£c c·∫ßn x√°c nh·∫≠n
 * @param {string} adminId - ID c·ªßa admin x√°c nh·∫≠n
 * @returns {Object} Th·ªëng k√™ k·∫øt qu·∫£ thanh to√°n
 */
exports.confirmPayouts = async (betIds, adminId) => {
  if (!Array.isArray(betIds) || betIds.length === 0) {
    throw new ApiError(400, 'C·∫ßn cung c·∫•p danh s√°ch ID c∆∞·ª£c');
  }
  
  // Th·ªëng k√™
  const summary = {
    totalProcessed: betIds.length,
    totalApproved: 0,
    totalAmount: 0,
    users: {}
  };
  
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const bets = await Bet.find({ 
      _id: { $in: betIds },
      status: 'won',
      paymentStatus: 'pending'
    }).populate('userId').session(session);
    
    if (bets.length === 0) {
      throw new ApiError(404, 'Kh√¥ng t√¨m th·∫•y c∆∞·ª£c h·ª£p l·ªá ƒë·ªÉ x√°c nh·∫≠n');
    }
    
    for (const bet of bets) {
      const user = bet.userId;
      
      // C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n
      bet.paymentStatus = 'approved';
      bet.paymentConfirmedBy = adminId;
      bet.paymentConfirmedAt = new Date();
      
      // C·∫≠p nh·∫≠t s·ªë d∆∞ ng∆∞·ªùi d√πng
      user.balance += bet.winAmount;
      
      // C·∫≠p nh·∫≠t th·ªëng k√™
      summary.totalApproved++;
      summary.totalAmount += bet.winAmount;
      
      const userKey = user._id.toString();
      if (!summary.users[userKey]) {
        summary.users[userKey] = {
          telegramId: user.telegramId,
          username: user.username,
          betCount: 0,
          amount: 0
        };
      }
      summary.users[userKey].betCount++;
      summary.users[userKey].amount += bet.winAmount;
      
      // L∆∞u thay ƒë·ªïi
      await bet.save({ session });
      await user.save({ session });
      
      // C·∫≠p nh·∫≠t cache
      try {
        await redisClient.setEx(`user:${user.telegramId}`, config.cacheExpiry, JSON.stringify(user));
      } catch (redisErr) {
        logger.error('Redis cache error:', redisErr);
      }
      
      // Th√¥ng b√°o cho ng∆∞·ªùi d√πng
      const message = `üí∞ *TH√îNG B√ÅO THANH TO√ÅN* üí∞\n\n` +
        `Xin ch√∫c m·ª´ng! Ti·ªÅn th∆∞·ªüng cho c∆∞·ª£c c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c chuy·ªÉn v√†o t√†i kho·∫£n.\n\n` +
        `üéÆ Lo·∫°i c∆∞·ª£c: ${bet.betType}\n` +
        `üî¢ S·ªë c∆∞·ª£c: ${bet.numbers}\n` +
        `üíµ Ti·ªÅn th·∫Øng: ${helper.formatCurrency(bet.winAmount)}\n\n` +
        `S·ªë d∆∞ hi·ªán t·∫°i: ${helper.formatCurrency(user.balance)}`;
      
      await telegramService.sendMessage(user.telegramId, message);
    }
    
    // Commit transaction
    await session.commitTransaction();
    
    return summary;
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error confirming payouts:', error);
    throw error;
  } finally {
    session.endSession();
  }
};

/**
 * L·∫•y danh s√°ch c∆∞·ª£c ch·ªù thanh to√°n
 * @param {Object} filters - C√°c ƒëi·ªÅu ki·ªán l·ªçc
 * @returns {Promise<Array>} Danh s√°ch c∆∞·ª£c
 */
exports.getPendingPayouts = async (filters = {}) => {
  // M·∫∑c ƒë·ªãnh l·ªçc c√°c c∆∞·ª£c tr√∫ng v√† ch∆∞a thanh to√°n
  let query = { status: 'won', paymentStatus: 'pending' };
  
  // √Åp d·ª•ng c√°c b·ªô l·ªçc
  if (filters.resultId) {
    query.resultId = filters.resultId;
  }
  
  if (filters.startDate && filters.endDate) {
    query.createdAt = { $gte: filters.startDate, $lte: filters.endDate };
  }
  
  if (filters.betType) {
    query.betType = filters.betType;
  }
  
  // L·∫•y danh s√°ch c∆∞·ª£c
  const pendingPayouts = await Bet.find(query)
    .populate('userId', 'telegramId username balance')
    .populate('resultId', 'date weekday')
    .sort({ createdAt: -1 });
  
  // T·∫°o th·ªëng k√™ t√≥m t·∫Øt
  const summary = {
    totalBets: pendingPayouts.length,
    totalAmount: pendingPayouts.reduce((sum, bet) => sum + bet.winAmount, 0),
    betTypeBreakdown: {},
    userBreakdown: {}
  };
  
  // Th·ªëng k√™ theo lo·∫°i c∆∞·ª£c v√† ng∆∞·ªùi d√πng
  for (const bet of pendingPayouts) {
    // Th·ªëng k√™ theo lo·∫°i c∆∞·ª£c
    if (!summary.betTypeBreakdown[bet.betType]) {
      summary.betTypeBreakdown[bet.betType] = {
        count: 0,
        amount: 0
      };
    }
    summary.betTypeBreakdown[bet.betType].count++;
    summary.betTypeBreakdown[bet.betType].amount += bet.winAmount;
    
    // Th·ªëng k√™ theo ng∆∞·ªùi d√πng
    const userId = bet.userId._id.toString();
    if (!summary.userBreakdown[userId]) {
      summary.userBreakdown[userId] = {
        telegramId: bet.userId.telegramId,
        username: bet.userId.username,
        count: 0,
        amount: 0
      };
    }
    summary.userBreakdown[userId].count++;
    summary.userBreakdown[userId].amount += bet.winAmount;
  }
  
  return {
    pendingPayouts,
    summary
  };
};

/**
 * Tr√≠ch xu·∫•t t·∫•t c·∫£ c√°c s·ªë t·ª´ k·∫øt qu·∫£
 * @param {Object} result - K·∫øt qu·∫£ x·ªï s·ªë
 * @returns {Object} C√°c s·ªë ƒë√£ tr√≠ch xu·∫•t
 */
function extractResultNumbers(result) {
  const twoDigits = [];
  const threeDigits = [];
  const fourDigits = [];
  const provinceResults = {};
  
  for (const province of result.provinces) {
    const provinceCode = province.code;
    provinceResults[provinceCode] = {
      twoDigits: [],
      threeDigits: [],
      fourDigits: []
    };
    
    // 2D: Gi·∫£i 8 v√† 2 s·ªë cu·ªëi c·ªßa t·∫•t c·∫£ c√°c gi·∫£i
    provinceResults[provinceCode].twoDigits.push(province.results.eighth);
    provinceResults[provinceCode].twoDigits.push(province.results.special.slice(-2));
    provinceResults[provinceCode].twoDigits.push(province.results.first.slice(-2));
    provinceResults[provinceCode].twoDigits.push(province.results.second.slice(-2));
    
    for (const num of province.results.third) {
      provinceResults[provinceCode].twoDigits.push(num.slice(-2));
    }
    
    for (const num of province.results.fourth) {
      provinceResults[provinceCode].twoDigits.push(num.slice(-2));
    }
    
    provinceResults[provinceCode].twoDigits.push(province.results.fifth.slice(-2));
    
    for (const num of province.results.sixth) {
      provinceResults[provinceCode].twoDigits.push(num.slice(-2));
    }
    
    provinceResults[provinceCode].twoDigits.push(province.results.seventh.slice(-2));
    
    // 3D: Gi·∫£i 7 v√† 3 s·ªë cu·ªëi c·ªßa gi·∫£i ƒë·∫∑c bi·ªát
    provinceResults[provinceCode].threeDigits.push(province.results.seventh);
    provinceResults[provinceCode].threeDigits.push(province.results.special.slice(-3));
    provinceResults[provinceCode].threeDigits.push(province.results.first.slice(-3));
    provinceResults[provinceCode].threeDigits.push(province.results.second.slice(-3));
    
    for (const num of province.results.third) {
      provinceResults[provinceCode].threeDigits.push(num.slice(-3));
    }
    
    for (const num of province.results.fourth) {
      provinceResults[provinceCode].threeDigits.push(num.slice(-3));
    }
    
    provinceResults[provinceCode].threeDigits.push(province.results.fifth.slice(-3));
    
    for (const num of province.results.sixth) {
      provinceResults[provinceCode].threeDigits.push(num.slice(-3));
    }
    
    // 4D: T·∫•t c·∫£ c√°c s·ªë 4 ch·ªØ s·ªë t·ª´ c√°c gi·∫£i
    for (const num of province.results.sixth) {
      provinceResults[provinceCode].fourDigits.push(num);
    }
    
    provinceResults[provinceCode].fourDigits.push(province.results.fifth);
    
    // Th√™m v√†o danh s√°ch t·ªïng h·ª£p
    twoDigits.push(...provinceResults[provinceCode].twoDigits);
    threeDigits.push(...provinceResults[provinceCode].threeDigits);
    fourDigits.push(...provinceResults[provinceCode].fourDigits);
  }
  
  return {
    twoDigits,
    threeDigits,
    fourDigits,
    provinceResults
  };
}

/**
 * Ki·ªÉm tra c∆∞·ª£c 2D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Array} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function check2D(betNumber, resultNumbers) {
  return resultNumbers.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c 3D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Array} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function check3D(betNumber, resultNumbers) {
  return resultNumbers.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c 4D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Array} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function check4D(betNumber, resultNumbers) {
  return resultNumbers.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c Bao l√¥ 2D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Object} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @param {string} provinceCode - M√£ t·ªânh
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function checkBaoLo2D(betNumber, resultNumbers, provinceCode) {
  // N·∫øu kh√¥ng c√≥ m√£ t·ªânh, ki·ªÉm tra t·∫•t c·∫£ c√°c t·ªânh
  if (!provinceCode) {
    return resultNumbers.twoDigits.includes(betNumber);
  }
  
  // N·∫øu c√≥ m√£ t·ªânh, ch·ªâ ki·ªÉm tra t·ªânh ƒë√≥
  if (!resultNumbers.provinceResults[provinceCode]) {
    return false;
  }
  
  return resultNumbers.provinceResults[provinceCode].twoDigits.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c Bao l√¥ 3D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Object} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @param {string} provinceCode - M√£ t·ªânh
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function checkBaoLo3D(betNumber, resultNumbers, provinceCode) {
  // N·∫øu kh√¥ng c√≥ m√£ t·ªânh, ki·ªÉm tra t·∫•t c·∫£ c√°c t·ªânh
  if (!provinceCode) {
    return resultNumbers.threeDigits.includes(betNumber);
  }
  
  // N·∫øu c√≥ m√£ t·ªânh, ch·ªâ ki·ªÉm tra t·ªânh ƒë√≥
  if (!resultNumbers.provinceResults[provinceCode]) {
    return false;
  }
  
  return resultNumbers.provinceResults[provinceCode].threeDigits.includes(betNumber);
}

/**
 * Ki·ªÉm tra c∆∞·ª£c Bao l√¥ 4D
 * @param {string} betNumber - S·ªë c∆∞·ª£c
 * @param {Object} resultNumbers - C√°c s·ªë k·∫øt qu·∫£
 * @param {string} provinceCode - M√£ t·ªânh
 * @returns {boolean} K·∫øt qu·∫£ ki·ªÉm tra
 */
function checkBaoLo4D(betNumber, resultNumbers, provinceCode) {
  // N·∫øu kh√¥ng c√≥ m√£ t·ªânh, ki·ªÉm tra t·∫•t c·∫£ c√°c t·ªânh
  if (!provinceCode) {
    return resultNumbers.fourDigits.includes(betNumber);
  }
  
  // N·∫øu c√≥ m√£ t·ªânh, ch·ªâ ki·ªÉm tra t·ªânh ƒë√≥
  if (!resultNumbers.provinceResults[provinceCode]) {
    return false;
  }
  
  return resultNumbers.provinceResults[provinceCode].fourDigits.includes(betNumber);
}

/**
 * Th√¥ng b√°o k·∫øt qu·∫£ m·ªõi
 * @param {Object} result - K·∫øt qu·∫£ x·ªï s·ªë
 */
exports.notifyResult = async (result) => {
  const channelId = config.telegramChannelId;
  if (!channelId) {
    logger.error('TELEGRAM_CHANNEL_ID not configured');
    return;
  }
  
  try {
    // Format ng√†y
    const formattedDate = new Date(result.date).toLocaleDateString('vi-VN');
    
    let message = `üé≤ *K·∫æT QU·∫¢ X·ªî S·ªê ${result.region.toUpperCase()} - ${formattedDate} (${result.weekday})*\n\n`;
    
    // Th√¥ng tin t·ª´ng t·ªânh
    for (const province of result.provinces) {
      message += `üèÜ *${province.name.toUpperCase()} (${province.code})*\n`;
      message += `‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n`;
      message += `üî∏ Gi·∫£i 8: ${province.results.eighth}\n`;
      message += `üî∏ Gi·∫£i 7: ${province.results.seventh}\n`;
      message += `üî∏ Gi·∫£i 6: ${province.results.sixth.join(', ')}\n`;
      message += `üî∏ Gi·∫£i 5: ${province.results.fifth}\n`;
      message += `üî∏ Gi·∫£i 4: ${province.results.fourth.join(', ')}\n`;
      message += `üî∏ Gi·∫£i 3: ${province.results.third.join(', ')}\n`;
      message += `üî∏ Gi·∫£i 2: ${province.results.second}\n`;
      message += `üî∏ Gi·∫£i 1: ${province.results.first}\n`;
      message += `üî∏ Gi·∫£i ƒê·∫∑c Bi·ªát: ${province.results.special}\n\n`;
    }
    
    // Th√™m th√¥ng tin ph·ª•
    message += `üì± Ki·ªÉm tra v√© s·ªë c·ªßa b·∫°n ngay b√¢y gi·ªù!`;
    
    await telegramService.sendMessage(channelId, message, { parse_mode: 'Markdown' });
  } catch (error) {
    logger.error('Failed to notify result:', error);
  }
};